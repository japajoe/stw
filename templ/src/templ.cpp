// MIT License
// Copyright Â© 2025 W.M.R Jap-A-Joe

// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "templ.hpp"
#include <string>
#include <vector>
#include <set>
#include <cstdint>
#include <filesystem>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <regex>
#include <stdexcept>

namespace templ
{
	namespace fs = std::filesystem;

	static std::string description = "//This file is generated by the 'templ' library. Do not modify.\n";

	static std::string headerStart =
		R"(#define WRITE_TO_OUTPUT(str, len) output.append(str, len)

#define WRITE_STRING_LITERAL(val) \
    { \
		WRITE_TO_OUTPUT(val, strlen(val)); \
    }

#define WRITE_STRING(val) \
    { \
		WRITE_TO_OUTPUT(val.data(), val.size()); \
    }

#define WRITE_INT(val) \
    { \
		std::string v = std::to_string(val); \
		WRITE_TO_OUTPUT(v.data(), v.size()); \
    }

#define WRITE_DOUBLE(val) \
    { \
		std::string v = std::to_string(val); \
		WRITE_TO_OUTPUT(v.data(), v.size()); \
    }

#define echo(val) \
    { \
		ss << val; \
		if (!ss.fail()) \
			output.append(ss.str()); \
		ss.clear(); \
    })";

	static std::string headerEnd =
		R"(#undef WRITE_TO_OUTPUT
#undef WRITE_STRING_LITERAL
#undef WRITE_INT
#undef WRITE_DOUBLE)";

	static std::string get_file_name(const std::string &filePath, bool stripExtension = true)
	{
		size_t lastSlashPos = filePath.find_last_of("/\\");

		std::string filename = (lastSlashPos == std::string::npos)
								   ? filePath
								   : filePath.substr(lastSlashPos + 1);

		size_t dotPos = filename.find_last_of('.');

		if (dotPos == std::string::npos || !stripExtension)
			return filename;

		return filename.substr(0, dotPos);
	}

	static std::string to_upper(const std::string &str)
	{
		std::string result = str;
		std::transform(result.begin(), result.end(), result.begin(), ::toupper);
		return result;
	}

	static std::string to_lower(const std::string &str)
	{
		std::string result = str;
		std::transform(result.begin(), result.end(), result.begin(), ::tolower);
		return result;
	}

	static bool create_directory_if_not_exist(const std::string &path)
	{
		fs::path directoryPath(path);

		if (!fs::exists(directoryPath) && !fs::is_directory(directoryPath))
		{
			if (!fs::create_directory(fs::path("templates")))
				return false;
		}
		return true;
	}

	static bool write_all_text(const std::string &filePath, const std::string &text)
	{
		std::ofstream f(filePath, std::ios_base::out);
		if (f.is_open())
		{
			f << text;
			f.close();
			return true;
		}
		return false;
	}

	static void emit_code(const std::string &input, std::string &output)
	{
		output += input;
	}

	static void emit_byte_array(const std::string &input, std::string &output)
	{
		std::ostringstream oss;

		oss << "WRITE_TO_OUTPUT(\"";

		for (size_t i = 0; i < input.size(); i++)
		{
			oss << std::dec << '\\' << 'x';
			oss << std::hex << std::setw(2) << std::setfill('0') << (int)input[i];
		}
		oss << std::dec << "\", " << input.size() << ");\n";
		output += oss.str();
	}

	static std::string extract_includes_and_remove(std::string &templateString)
	{
		// Regular expression to match the full #include directives (both <...> and "..." forms)
		std::regex includeRegex(R"(\#include\s*(<[^>]+>|"[^"]+"))");

		std::smatch match;
		std::set<std::string> includes;

		// Required includes
		includes.insert("#include <string>");
		includes.insert("#include <cstring>");
		includes.insert("#include <sstream>");

		// Find all #include matches
		std::string::const_iterator searchStart(templateString.cbegin());
		while (std::regex_search(searchStart, templateString.cend(), match, includeRegex))
		{
			// Capture the full #include directive (without extra prefix)
			std::string includeDirective = match.str();
			includes.insert(includeDirective);
			// Move the search start position past the current match
			searchStart = match.suffix().first;
		}

		// Removes all #include directives from the templateString
		templateString = std::regex_replace(templateString, includeRegex, "");

		// Build a string with the list of includes (one per line)
		std::string includeList;
		for (const auto &include : includes)
		{
			if (!includeList.empty())
			{
				includeList += "\n";
			}
			includeList += include;
		}

		return includeList;
	}

	static std::string parse(const std::string &templateString)
	{
		const std::string delimiterOpen = "<?cpp";
		const std::string delimiterClose = "?>";

		size_t pos = 0;
		size_t prevPos = 0;
		std::string output;

		// If there's no <cpp>, we start in HTML mode
		bool inCppMode = templateString.find(delimiterOpen, pos) == std::string::npos;

		while (pos < templateString.size())
		{
			if (inCppMode)
			{
				// Find the start of C++ code
				size_t cppStart = templateString.find(delimiterOpen, pos);
				if (cppStart != std::string::npos)
				{
					// Handle HTML up to the start of C++ code
					std::string htmlPart = templateString.substr(prevPos, cppStart - prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}

					// Handle C++ code
					size_t cppEnd = templateString.find(delimiterClose, cppStart);
					if (cppEnd != std::string::npos)
					{
						// Emit the C++ code inside the <cpp> block
						std::string cppCode = templateString.substr(cppStart + delimiterOpen.length(), cppEnd - cppStart - delimiterOpen.length());
						if (!cppCode.empty())
						{
							emit_code(cppCode, output);
						}

						// Update positions to continue scanning
						pos = cppEnd + delimiterClose.length();
						prevPos = pos;

						// After C++ code, switch to HTML mode
						inCppMode = false;
					}
					else
					{
						// No closing delimiter found, treat the rest as C++
						std::string remainingCpp = templateString.substr(cppStart);
						if (!remainingCpp.empty())
						{
							emit_code(remainingCpp, output);
						}
						break;
					}
				}
				else
				{
					// No more C++ code, handle remaining HTML
					std::string htmlPart = templateString.substr(prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}
					break;
				}
			}
			else
			{
				// If we're in HTML mode, find the next <cpp> block
				size_t cppStart = templateString.find(delimiterOpen, pos);
				if (cppStart != std::string::npos)
				{
					// Handle HTML up to the next <cpp>
					std::string htmlPart = templateString.substr(prevPos, cppStart - prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}

					// Update positions to continue scanning
					pos = cppStart;
					prevPos = pos;

					// After HTML, switch to C++ mode
					inCppMode = true;
				}
				else
				{
					// No more <cpp> blocks, handle remaining HTML
					std::string htmlPart = templateString.substr(prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}
					break;
				}
			}
		}

		return output;
	}

	void create_template(const char *filePath, const char *outputFilePath)
	{
		if (!fs::exists(fs::path(filePath)))
			throw std::runtime_error("The given file does not exist: " + std::string(filePath));

		std::ifstream f(filePath);

		if (!f.is_open())
			throw std::runtime_error("Could not open file: " + std::string(filePath));

		std::ostringstream contentStream;
		contentStream << f.rdbuf();
		f.close();

		std::string content = contentStream.str();
		std::string fileName = get_file_name(filePath);
		std::string className = to_lower(fileName) + "_view";
		std::string fileIdentifier = to_upper(fileName + "_view");
		std::string beginFileIdentifier = "#ifndef " + fileIdentifier + "_HPP\n" +
										  "#define " + fileIdentifier + "_HPP\n\n";

		std::string endFileIdentifier = "#endif //" + fileIdentifier + "_HPP";

		std::string includes = extract_includes_and_remove(content);

		std::string output = description +							 
							 beginFileIdentifier +
							 includes + "\n\n" +
							 headerStart + "\n\n" +
							 "class " + className + "\n" +
							 "{\n" +
							 "public:\n" +
							 "    std::string get()\n" +
							 "    {\n" +
							 "        std::string output;\n" +
							 "        std::stringstream ss;\n" +
							 parse(content) + "\n\n" +
							 "        return output;\n" +
							 "    }\n" +
							 "};\n\n" +
							 headerEnd + "\n\n" +
							 endFileIdentifier + "\n";

		std::string directoryPath("templates");

		if (!create_directory_if_not_exist(directoryPath))
		{
			if (!fs::create_directory(fs::path("templates")))
				throw std::runtime_error("Failed to create directory: " + directoryPath);
		}

		if (outputFilePath == nullptr)
		{
			std::string generatedFilePath = directoryPath + "/" + fileName + "_view.hpp";
			if (write_all_text(generatedFilePath, output))
				std::cout << "Generated: " << generatedFilePath << '\n';
			else
				std::cout << "Failed to generate:" << generatedFilePath << '\n';
		}
		else
		{
			if (write_all_text(outputFilePath, output))
				std::cout << "Generated " << outputFilePath << '\n';
			else
				std::cout << "Failed to generate:" << outputFilePath << '\n';
		}
	}
}