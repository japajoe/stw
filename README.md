# stw
A library for making web based applications.

# Features
- HTTP server.
- HTTP client.
- Web socket implementation for client and server.
- Template generator that lets you mix HTML and C++.

# Requirements for Linux
- libcurl (libcurl.so)
- libssl (libssl.so)
- libcrypto (libcrypto.so)

# Requirements for Windows
- libcurl (libcurl-x64.dll)
- libssl (libssl-3-x64.dll)
- libcrypto (libcrypto-3-x64.dll)

# Requirements for Mac
- Work in progress, but the `stw::socket` class does work on Mac as it is.

# Notes on requirements
I've removed the old http server implementation, the new one does not use any TLS. As a result, you only need to have the  libraries if you want to use the `stw::web_socket` and `stw::http_client`. No linking is required with any libraries, but on Linux you must have these libraries somewhere in your system path. On Windows you must place the dll files in the same directory as the executable. MacOS is not fully supported (yet).

# Getting started
Before using the library make sure to call stw::load_library.

# Mixing HTML and C++
Sure, the code highlighting isn't super great, and your code editor won't offer any code completion. On top of that, this abomination can be cumbersome to debug. That said, don't act like this isn't a cool feature!

```php
<?cpp
	std::string title = "Example website";
?>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?cpp echo(title); ?></title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
        }
        h3 {
            color: #333;
        }
        p {
            color: #666;
        }
        footer {
            margin-top: 20px;
            font-size: 0.8em;
            color: #888;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px; /* Increased padding for better visibility */
            text-align: left; /* Ensuring left alignment for all text */
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold; /* Bold text for headers */
        }
        tr:nth-child(even) {
            background-color: #f9f9f9; /* Alternate row color for better readability */
        }
    </style>
</head>
<body>
	<h1>Simple web page</h1>
    <p>This is an example of a page generated by a template.</p>
	
    <table>
        <thead>
            <tr>
                <th>Header</th>
                <th>Value</th>
            </tr>
        </thead>
        <tbody>
            <?cpp for(const auto& [key, value] : get_headers()) { ?>
                <tr>
                    <td><?cpp echo(key); ?></td>
                    <td><?cpp echo(value); ?></td>
                </tr>
            <?cpp } ?>
        </tbody>
    </table>

    <footer>
        <p>Powered by stw</p>
    </footer>
</body>
</html>
```

To generate a header file from this template (or even multiple in a directory), you can do something like this:
```cpp
#include "stw/templating/templ.hpp"

int main()
{
	stw::templ::config config = {
		.inputDirectory = "../../web/website/www/templates",
		.outputDirectory = "../../web/include/views",
		.includeDirectory = "../../web/website/www/templates/include",
		.outputFileExtension = "hpp"
	};

	try
	{
		stw::templ::create_templates(config);
	}
	catch(const std::runtime_error &ex)
	{
		std::cout << ex.what() << '\n';
	}

	return 0;
}
```
If successful, the generated files will be in the output directory. The class names will have the form `name_view.hpp`. You can now use these files in your project like so:

```cpp
#include "stw/stw.hpp"
#include "index_view.html" //Assuming you have a class called index_view

class index_controller : public stw::http_controller
{
public:
	stw::http_response on_get(const stw::http_request &request, stw::network_stream *stream) override
	{
		auto responseInfo = view.get(&request);
		stw::http_response response;
		response.statusCode = stw::http_status_code_ok;
		response.contentType = "text/html";
		response.content = std::make_shared<stw::memory_stream>(responseInfo->content.data(), responseInfo->content.size(), true);
		return response;
	}
private:
	index_view view;
};

int main()
{
	stw::load_library();

	stw::http_server_configuration config;
	stw::http_server server;
	stw::http_request_router router;

	if(!config.load_from_file("config.ini"))
		return -1;

	router.add<index_controller>("/");

	server.onRequest = [&] (const stw::http_request &request, stw::network_stream *stream) -> stw::http_response {
		// In principle, you just need to set the fields on the http_response object and return it
		// - The status code is mandatory
		// - Content can either be nullptr, std::shared_ptr<stw::memory_stream> or std::shared_ptr<stw::file_stream>
		// - Content passed in memory stream must be copied (pass true as last parameter to constructor)
		// - Content type must be set if the stream is set
		// - Headers are optional
		
		stw::http_response response;

		if(router.process_request(request, stream, response))
		{
			return response;
		}
		else
		{
			// If no route was found, the user may have requested a file
			std::string path = config.publicHtmlPath + request.path;

			// Checks if the file exists, and if it's inside the public html directory or any of its children
			if(stw::file::is_within_directory(path, config.publicHtmlPath))
			{
				response.statusCode = stw::http_status_code_ok;
				response.content = std::make_shared<stw::file_stream>(path, stw::file_access_read);
				response.contentType = stw::get_http_content_type(path);
				response.headers["Cache-Control"] = "max-age=3600";
			}
			else
			{
				response.statusCode = stw::http_status_code_not_found;
			}

			return response;
		}
	};

	return server.run(config);
}
```

# Disclaimer
This library is just for educational purposes. It is a means for me to have fun while exploring new concepts and improve my understanding of networking and cross-platform development. I might add or remove anything I want at any given time if it suits me. Use at your own discretion.
