// MIT License
// Copyright Â© 2025 W.M.R Jap-A-Joe

// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "templ.hpp"
#include "../system/runtime.hpp"
#include "../system/file.hpp"
#include "../system/directory.hpp"
#include "../system/string.hpp"
#include <vector>
#include <set>
#include <cstdint>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <regex>
#include <stdexcept>

namespace stw::templ
{
	static std::string outputTemplate =
R"(// This is an autogenerated file, do not modify unless you know what you are
// doing.
${INCLUDE_GUARD_START_1}
${INCLUDE_GUARD_START_2}

#include <cstring>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
${INCLUDES}

namespace stw
{
	struct http_request;
	struct http_response_info;
}

#define WRITE_TO_OUTPUT(str, len) m_ss_.write(str, len)
#define echo(val) m_ss_ << val

class ${CLASS_NAME}
{
  private:
	enum http_method {
		http_method_get,
		http_method_post,
		http_method_put,
		http_method_patch,
		http_method_delete,
		http_method_head,
		http_method_options,
		http_method_trace,
		http_method_connect,
		http_method_unknown
	};

	struct http_request {
		http_method m_method_;
		std::string m_path_;
		std::string m_httpVersion_;
		std::string m_ip_;
		uint64_t m_contentLength_;
		std::unordered_map<std::string, std::string> m_headers_;
		std::unordered_map<std::string, std::string> m_cookies_;
	};

	struct http_response_info {
		std::unordered_map<std::string, std::string> m_headers_;
		std::unordered_map<std::string, std::string> m_cookies_;
		std::string m_output_;
		std::string m_contentType_;
	};

	const http_request *m_requestInfo_;
	http_response_info m_responseInfo_;
	void *m_userData_;
	std::stringstream m_ss_;
  public:
	${CLASS_NAME}()
	{
		m_requestInfo_ = nullptr;
		m_userData_ = nullptr;
	}
	stw::http_response_info *get(const stw::http_request *requestInfo, void *userData = nullptr)
	{
		if(!requestInfo)
			throw std::runtime_error("${CLASS_NAME}::get requestInfo can not be null");

		m_requestInfo_ = reinterpret_cast<const http_request*>(requestInfo);
		m_userData_ = userData;
		
		${GENERATED_CODE}

		m_responseInfo_.m_output_ = m_ss_.str();
		m_responseInfo_.m_contentType_ = "text/html";

		m_ss_.str("");
		m_ss_.clear();

		return reinterpret_cast<stw::http_response_info*>(&m_responseInfo_);
	}
	std::string get_path() const
	{
		return this->m_requestInfo_->m_path_;
	}
	std::string get_ip() const
	{
		return this->m_requestInfo_->m_ip_;
	}
	void *get_user_data()
	{
		return this->m_userData_;
	}
};

#undef WRITE_TO_OUTPUT
#undef echo

${INCLUDE_GUARD_END})";

	static void write_log(const std::string &message)
	{
		std::cout << "templ: " << message << '\n';
	}

	static bool create_directory_if_not_exist(const std::string &path)
	{
		if (!stw::directory::exists(path))
		{
			if (!stw::directory::create(path))
				return false;
		}
		return true;
	}

	static void emit_code(const std::string &input, std::string &output)
	{
		output += input;
	}

	static void emit_byte_array(const std::string &input, std::string &output)
	{
		std::ostringstream oss;

		oss << "WRITE_TO_OUTPUT(\"";

		for (unsigned char c : input) 
		{
			oss << "\\x" << std::hex << std::setw(2) << std::setfill('0')
				<< static_cast<int>(c);
		}

		oss << std::dec << "\", " << input.size() << ");\n";
		output += oss.str();
	}

	static bool extract_include_tags_and_replace(std::string &templateString, const std::string &includePath)
	{
		std::regex includeRegex(R"(<include\s+path=["']([^"']+)["']\s*\/?>)", std::regex_constants::icase);
		
		std::smatch match;

		// We search and replace iteratively
		while (std::regex_search(templateString, match, includeRegex)) 
		{
			// match[0] is the full tag: <include path="filename.html">
			// match[1] is the captured path: filename.html
			std::string fullTag = match[0].str();
			std::string filePath = match[1].str();

			if(string::starts_with(filePath, "/"))
				filePath = filePath.substr(1);

			filePath = includePath + "/" + filePath;

			if(!file::exists(filePath))
			{
				std::cout << "Include file not found at path: " << filePath << '\n';
				return false;
			}

			std::string replacement = file::read_all_text(filePath);

			// Replace the first occurrence of the tag with the file content
			size_t pos = templateString.find(fullTag);
			if (pos != std::string::npos) 
			{
				templateString.replace(pos, fullTag.length(), replacement);
			}
		}

		return true;
	}

	static std::string extract_cpp_includes_and_remove(std::string &templateString)
	{
		// Regular expression to match the full #include directives (both <...> and "..." forms)
		std::regex includeRegex(R"(\#include\s*(<[^>]+>|"[^"]+"))");

		std::smatch match;
		std::set<std::string> includes;

		// Required includes
		includes.insert("#include <string>");
		includes.insert("#include <cstring>");
		includes.insert("#include <sstream>");
		includes.insert("#include <unordered_map>");
		includes.insert("#include <stdexcept>");

		// Find all #include matches
		std::string::const_iterator searchStart(templateString.cbegin());
		while (std::regex_search(searchStart, templateString.cend(), match, includeRegex))
		{
			// Capture the full #include directive (without extra prefix)
			std::string includeDirective = match.str();
			includes.insert(includeDirective);
			// Move the search start position past the current match
			searchStart = match.suffix().first;
		}

		// Removes all #include directives from the templateString
		templateString = std::regex_replace(templateString, includeRegex, "");

		// Build a string with the list of includes (one per line)
		std::string includeList;
		for (const auto &include : includes)
		{
			if (!includeList.empty())
			{
				includeList += "\n";
			}
			includeList += include;
		}

		return includeList;
	}

	static std::string parse(const std::string &templateString)
	{
		const std::string delimiterOpen = "<?cpp";
		const std::string delimiterClose = "?>";

		size_t pos = 0;
		size_t prevPos = 0;
		std::string output;

		// If there's no <cpp>, we start in HTML mode
		bool inCppMode = templateString.find(delimiterOpen, pos) == std::string::npos;

		while (pos < templateString.size())
		{
			if (inCppMode)
			{
				// Find the start of C++ code
				size_t cppStart = templateString.find(delimiterOpen, pos);
				if (cppStart != std::string::npos)
				{
					// Handle HTML up to the start of C++ code
					std::string htmlPart = templateString.substr(prevPos, cppStart - prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}

					// Handle C++ code
					size_t cppEnd = templateString.find(delimiterClose, cppStart);
					if (cppEnd != std::string::npos)
					{
						// Emit the C++ code inside the <cpp> block
						std::string cppCode = templateString.substr(cppStart + delimiterOpen.length(), cppEnd - cppStart - delimiterOpen.length());
						if (!cppCode.empty())
						{
							emit_code(cppCode, output);
						}

						// Update positions to continue scanning
						pos = cppEnd + delimiterClose.length();
						prevPos = pos;

						// After C++ code, switch to HTML mode
						inCppMode = false;
					}
					else
					{
						// No closing delimiter found, treat the rest as C++
						std::string remainingCpp = templateString.substr(cppStart);
						if (!remainingCpp.empty())
						{
							emit_code(remainingCpp, output);
						}
						break;
					}
				}
				else
				{
					// No more C++ code, handle remaining HTML
					std::string htmlPart = templateString.substr(prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}
					break;
				}
			}
			else
			{
				// If we're in HTML mode, find the next <cpp> block
				size_t cppStart = templateString.find(delimiterOpen, pos);
				if (cppStart != std::string::npos)
				{
					// Handle HTML up to the next <cpp>
					std::string htmlPart = templateString.substr(prevPos, cppStart - prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}

					// Update positions to continue scanning
					pos = cppStart;
					prevPos = pos;

					// After HTML, switch to C++ mode
					inCppMode = true;
				}
				else
				{
					// No more <cpp> blocks, handle remaining HTML
					std::string htmlPart = templateString.substr(prevPos);
					if (!htmlPart.empty())
					{
						emit_byte_array(htmlPart, output);
					}
					break;
				}
			}
		}

		return output;
	}

	bool create_template(const std::string &filePath, const std::string &includePath, const std::string &outputFilePath)
	{
		if(filePath.size() == 0)
			throw std::runtime_error("The given file path is empty");
			
		if (!file::exists(filePath))
			throw std::runtime_error("The given file does not exist: " + filePath);

		std::string rawCode = file::read_all_text(filePath);

		//First check if raw code has any <include file="somefile.html"> tags
		//If tags are found, extract the path, and past file contents in place
		if(!extract_include_tags_and_replace(rawCode, includePath))
			return false;

		//std::cout << rawCode << '\n';

		std::string generatedCode = parse(rawCode);
		std::string includes = extract_cpp_includes_and_remove(generatedCode);
		std::string fileName = stw::file::get_name(filePath, false);
		std::string className = stw::string::to_lower(fileName) + "_view";
		std::string fileIdentifier = stw::string::to_upper(fileName + "_view");

		std::string output = outputTemplate;

		output = stw::string::replace(output, "${INCLUDE_GUARD_START_1}", "#ifndef " + fileIdentifier + "_HPP");
		output = stw::string::replace(output, "${INCLUDE_GUARD_START_2}", "#define " + fileIdentifier + "_HPP");
		output = stw::string::replace(output, "${INCLUDES}", includes);
		output = stw::string::replace(output, "${CLASS_NAME}", className);
		output = stw::string::replace(output, "${GENERATED_CODE}", generatedCode);
		output = stw::string::replace(output, "${INCLUDE_GUARD_END}", "#endif //" + fileIdentifier + "_HPP");

		auto saveFile = [] (const std::string &fileContent, const std::string &filePath) -> bool {
			if (file::write_all_text(filePath, fileContent))
			{
				write_log("Generated view: " + filePath);
				return true;
			}
			else
			{
				write_log("Failed to generate view:" + filePath);
				return false;
			}
		};

		// If no outputFilePath was given, we try to write the output to a newly created directory
		if (outputFilePath.size() == 0)
		{
			std::string directoryPath("templates");

			if (!create_directory_if_not_exist(directoryPath))
				throw std::runtime_error("Failed to create directory: " + directoryPath);

			std::string generatedFilePath = directoryPath + "/" + fileName + "_view.hpp";

			return saveFile(output, generatedFilePath);
		}
		else
		{
			return saveFile(output, outputFilePath);
		}
	}

	void create_templates(const config &config)
	{
		if(config.inputDirectory.size() == 0)
			throw std::runtime_error("inputDirectory can not be empty");

		if(config.outputDirectory.size() == 0)
			throw std::runtime_error("outputDirectory can not be empty");

		auto files = stw::directory::get_files(config.inputDirectory);

		if(files.size() == 0)
			throw std::runtime_error("The input directory does not exist or has no files");

		std::string extension = (config.outputFileExtension.size() > 0) ? config.outputFileExtension : "hpp";
		
		for(const auto &file : files)
		{
			std::string outputFile = config.outputDirectory + "/" + stw::file::get_name(file, false) + "_view." + extension;
			
			try
			{
				create_template(file, config.includeDirectory, outputFile);
			}
			catch(const std::runtime_error &ex)
			{
				std::cout << ex.what() << '\n';
			}
		}
	}
}